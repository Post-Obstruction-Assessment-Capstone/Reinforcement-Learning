
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/Utilities.ipynb
import os
import torch as T
import numpy as np
import pandas as pd
import cv2
import matplotlib
import matplotlib.pyplot as plt

class imagenetStats:
    def __init__(self, UseInception=True):
        self.UseInception=UseInception
        self.IMAGENET_DEFAULT_MEAN = (0.485, 0.456, 0.406)
        self.IMAGENET_DEFAULT_STD = (0.229, 0.224, 0.225)
        self.IMAGENET_INCEPTION_MEAN = (0.5, 0.5, 0.5)
        self.IMAGENET_INCEPTION_STD = (0.5, 0.5, 0.5)
    def getMean(self):
        if self.UseInception: return self.IMAGENET_INCEPTION_MEAN[0]

    def getSTD(self):
        if self.UseInception: return self.IMAGENET_INCEPTION_STD[0]


def set_seed(x):
    #random.seed(x)
    np.random.seed(x)
    T.manual_seed(x)
    T.backends.cudnn.deterministic = True
    T.backends.cudnn.benchmark = False
    if T.cuda.is_available():
        T.cuda.manual_seed_all(x)

def byte2np_RGB(response, Save=False, path='data', filename='Test', ClrFirst=True):
    img1d = np.fromstring(response.image_data_uint8, dtype=np.uint8)
    # reshape array to 4 channel image array H X W X 4
    if ClrFirst: img_rgb = img1d.reshape(3, response.height, response.width)
    else: img_rgb = img1d.reshape(response.height, response.width, 3)
    if Save:
        filename = os.path.join(path, filename)
        np.save(filename, img_rgb)
    return img_rgb

def byte2np_Depth(response, Save=False, path='data', filename='Test', Normalize=True):
    img1d = np.array(response.image_data_float, dtype=np.float)
    if Normalize:
        img1d = img1d * 3.5 + 30
        img1d[img1d > 255] = 255
        img1d=img1d/255
    depth = np.reshape(img1d, (response.height, response.width))
    if Save:
        filename = os.path.join(path, filename)
        np.save(filename, depth)
    return depth

def ChangeColor(img, clr_og, clr_new):
    r1, g1, b1 = clr_og # Original value
    r2, g2, b2 = clr_new # Value that we want to replace it with

    blue, green, red = img[:,:,0], img[:,:,1], img[:,:,2]
    mask = (red == r1) & (green == g1) & (blue == b1)
    img[:,:,:3][mask] = [b2, g2, r2]
    return img

def byte2np_Seg(response, Save=False, path='data', filename=f'Test'):
    img1d = np.fromstring(response.image_data_uint8, dtype=np.uint8)
    img = img1d.reshape(response.height, response.width, 3)
    # Change sky and road color
    road = [177, 172, 224] # RGB road
    sky = [128, 219, 130] # RGB Sky

    img=ChangeColor(img, clr_og=road, clr_new=[255,255,255])
    img=ChangeColor(img, clr_og=sky, clr_new=[0,0,0])
    # convert to greyscale
    img=cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)/255
    if Save:
        filename = os.path.join(path, filename)
        np.save(filename, img)
    return img

def Distance2Grnd(img, sz, rng=10):
    x,y=sz
    x=int(x/2)
    y=int(y/2)
    return np.mean(img[x-rng:x+rng,y-rng:y+rng])

def isRoadBelow(img, sz, rng=10):
    x,y=sz
    x=int(x/2)
    y=int(y/2)
    med=np.median(img[x-rng:x+rng,y-rng:y+rng])
    if med >0.98: return True
    else: return False

def plotcolorline(x, y, z, cmap='YlOrRd', norm=plt.Normalize(0.0, 1.0),
              linewidth=3, alpha=1.0):
    #breaks lines into segments and plots segment color as z value in colormap
    import matplotlib.collections as mcoll
    points = np.array([x, y]).T.reshape(-1, 1, 2)
    segments = np.concatenate([points[:-1], points[1:]], axis=1)
    lc = mcoll.LineCollection(segments, array=z, cmap=cmap, norm=norm,
                              linewidth=linewidth, alpha=alpha)
    ax = plt.gca()
    ax.add_collection(lc)

    return lc

class GPShistory:
    def __init__(self, position, velocity, reward, time_stamp, vehicle_name, image_size, maxspeed):
        self.columns=['x_position', 'y_position', 'z_position',
                     'x_velocity', 'y_velocity', 'z_velocity',
                     'Reward', 'time_stamp', 'vehicle_name']
        self.sz=image_size
        self.vehicle_name=vehicle_name
        self.maxspeed= maxspeed
        self.df=pd.DataFrame([[position.x_val, position.y_val, position.z_val,
                               velocity.x_val, velocity.y_val, velocity.z_val,
                              reward, time_stamp,vehicle_name]], columns=self.columns)

    def appendGPShistory(self, position, velocity, reward, time_stamp, vehicle_name):
        self.df.loc[len(self.df)]= [position.x_val, position.y_val, position.z_val,
                                    velocity.x_val, velocity.y_val, velocity.z_val,
                                    reward, time_stamp,vehicle_name]

    def saveGPS2csv(self, filename):
        self.df.to_csv(filename, index=False)

    def loadGPScsv(self, filename):
        self.df=pd.read_csv(filename)

    def GPS2image(self, Save=False, path='data', filename='Test'):
        df=self.df.copy()
        # no fly zones still need to be implimented
        df['VELOCITY']=np.sqrt(df['x_velocity']*df['x_velocity']+df['y_velocity']*df['y_velocity']+df['z_velocity']*df['z_velocity'])
        # ensures the current vehicle is plotted last
        vehicle_lst=list(df[df['vehicle_name']!=self.vehicle_name]['vehicle_name'].dropna().unique())+[self.vehicle_name]
        #################################### Plotting #########################################################
        fig, ax = plt.subplots(figsize=(5,5))
        # add reward colors
        frame=df[df['Reward']>0].copy()
        plt.plot(frame['x_position'], frame['y_position'], marker='o', color="green", ms=12,linestyle='None')
        frame=df[df['Reward']<0].copy()
        plt.plot(frame['x_position'], frame['y_position'], marker='o', color="red", ms=8,linestyle='None')

        for v_name in vehicle_lst:
            frame=df[df['vehicle_name']==v_name].copy()
            if v_name==self.vehicle_name:
                clr='YlOrRd'; rad=20
                x_cntr=frame.loc[frame.index[-1],'x_position']
                y_cntr=frame.loc[frame.index[-1],'y_position']
                # plt.plot(frame['x_position'], frame['y_position'], color='k', lw=6) # makes a black edge to line (not working in linux)
                # set the most recent position to the center of plot and shows 20 meters in all directions
                plt.xlim(x_cntr-rad,x_cntr+rad); plt.ylim(y_cntr-rad,y_cntr+rad)

            else: clr= 'Greys'
            # line plot where color is velocity
            lc = plotcolorline(frame['x_position'], frame['y_position'],frame['VELOCITY'],
                           cmap=clr, norm=plt.Normalize(-1, self.maxspeed), linewidth=4,alpha=1.0)
            #Last Location
            plt.plot(frame.loc[frame.index[-1],'x_position'], frame.loc[frame.index[-1],'y_position']
                     , marker='P', color="k", ms=12, markeredgecolor='white',linestyle='None')

            #honey I'm home
            plt.plot(frame.loc[frame.index[0],'x_position'], frame.loc[frame.index[0],'y_position']
                     , marker='o', color="gray", ms=8, markeredgecolor='black',linestyle='None')

        plt.tight_layout()
        ax=plt.gca(); ax.set_axis_off()
        ax.add_patch(patches.Rectangle((x_cntr-rad,y_cntr-rad+1), width=rad*2-1, height=rad*2-1, ec='k', facecolor=(0,0,0,0)))
        fig.canvas.draw()

        # plot to image array
        arr = np.frombuffer(fig.canvas.tostring_rgb(), dtype=np.uint8)
        arr = arr.reshape(fig.canvas.get_width_height()[::-1] + (3,))
        plt.close(fig)
        plt.figure().clear()
        plt.close()
        plt.cla()
        plt.clf()
        # this padding only works for 224x224 images
        arr=cv2.resize(arr[11:arr.shape[0]-28,38:arr.shape[0]-10], (self.sz), interpolation=cv2.INTER_CUBIC)
        img=arr.copy()
        arr=arr.reshape((3,)+self.sz)
        if Save:
            filename = os.path.join(path, filename)
            np.save(filename, arr)
            fig = plt.figure()
            plt.imshow(img)
            fig.savefig(filename+'.png')
            plt.close(fig)

        return arr

