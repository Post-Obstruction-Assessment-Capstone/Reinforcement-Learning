
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/Utilities.ipynb
import os
import torch as T
import numpy as np
import math
import pandas as pd
import cv2
import math
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import itertools

class imagenetStats:
    def __init__(self, UseInception=True):
        self.UseInception=UseInception
        self.IMAGENET_DEFAULT_MEAN = (0.485, 0.456, 0.406)
        self.IMAGENET_DEFAULT_STD = (0.229, 0.224, 0.225)
        self.IMAGENET_INCEPTION_MEAN = (0.5, 0.5, 0.5)
        self.IMAGENET_INCEPTION_STD = (0.5, 0.5, 0.5)
    def getMean(self):
        if self.UseInception: return self.IMAGENET_INCEPTION_MEAN[0]

    def getSTD(self):
        if self.UseInception: return self.IMAGENET_INCEPTION_STD[0]


def set_seed(x):
    #random.seed(x)
    np.random.seed(x)
    T.manual_seed(x)
    T.backends.cudnn.deterministic = True
    T.backends.cudnn.benchmark = False
    if T.cuda.is_available():
        T.cuda.manual_seed_all(x)

def byte2np_RGB(response, Save=False, path='data', filename='Test', ClrFirst=True):
    img1d = np.fromstring(response.image_data_uint8, dtype=np.uint8)
    # reshape array to 4 channel image array H X W X 4
    if ClrFirst: img_rgb = img1d.reshape(3, response.height, response.width)
    else: img_rgb = img1d.reshape(response.height, response.width, 3)
    if Save:
        filename = os.path.join(path, filename)
        np.save(filename, img_rgb)
    return img_rgb

def byte2np_Depth(response, Save=False, path='data', filename='Test', Normalize=True):
    img1d = np.array(response.image_data_float, dtype=np.float)
    if Normalize:
        img1d = img1d * 3.5 + 30
        img1d[img1d > 255] = 255
        img1d=img1d/255
    depth = np.reshape(img1d, (response.height, response.width))
    if Save:
        filename = os.path.join(path, filename)
        np.save(filename, depth)
    return depth

def ChangeColor(img, clr_og, clr_new):
    r1, g1, b1 = clr_og # Original value
    r2, g2, b2 = clr_new # Value that we want to replace it with

    blue, green, red = img[:,:,0], img[:,:,1], img[:,:,2]
    mask = (red == r1) & (green == g1) & (blue == b1)
    img[:,:,:3][mask] = [b2, g2, r2]
    return img

def byte2np_Seg(response, Save=False, path='data', filename=f'Test'):
    img1d = np.fromstring(response.image_data_uint8, dtype=np.uint8)
    img = img1d.reshape(response.height, response.width, 3)
    # Change sky and road color
    road = [177, 172, 224] # RGB road
    sky = [128, 219, 130] # RGB Sky

    img=ChangeColor(img, clr_og=road, clr_new=[255,255,255])
    img=ChangeColor(img, clr_og=sky, clr_new=[0,0,0])
    # convert to greyscale
    img=cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)/255
    if Save:
        filename = os.path.join(path, filename)
        np.save(filename, img)
    return img

def Distance2Grnd(img, sz, rng=10):
    x,y=sz
    x=int(x/2)
    y=int(y/2)
    return np.mean(img[x-rng:x+rng,y-rng:y+rng])

def isRoadBelow(img, sz, rng=10):
    x,y=sz
    x=int(x/2)
    y=int(y/2)
    med=np.median(img[x-rng:x+rng,y-rng:y+rng])
    if med >0.98: return True
    else: return False

def Value2Color(val, vmin=0, vmax=1, palette='YlOrRd', zerocolor='#e3e3e3'):
    """Input value from vmin to vmax returns hex color based on value and palette"""
    import matplotlib as mpl
    import matplotlib.cm as cm
    try:
        if np.isnan(val):
            clr='#e3e3e3' # grey
        elif val==0: clr=zerocolor# green if zero
        else:
            norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)
            cmap = cm.get_cmap(palette)
            m = cm.ScalarMappable(norm=norm, cmap=cmap)
            rgba=m.to_rgba(val)
            clr=mpl.colors.to_hex(rgba)
    except: clr='#e3e3e3' # grey
    return clr

def plotcolorline(x, y, z, cmap='YlOrRd', norm=plt.Normalize(0.0, 1.0),
              linewidth=3, alpha=1.0):
    #breaks lines into segments and plots segment color as z value in colormap
    import matplotlib.collections as mcoll
    points = np.array([x, y]).T.reshape(-1, 1, 2)
    segments = np.concatenate([points[:-1], points[1:]], axis=1)
    lc = mcoll.LineCollection(segments, array=z, cmap=cmap, norm=norm,
                              linewidth=linewidth, alpha=alpha)
    ax = plt.gca()
    ax.add_collection(lc)

    return lc

class GPShistory:
    def __init__(self, position, velocity, reward, time_stamp, vehicle_name, image_size, maxspeed):
        self.columns=['x_position', 'y_position', 'z_position',
                     'x_velocity', 'y_velocity', 'z_velocity',
                     'Reward', 'time_stamp', 'vehicle_name']
        self.sz=image_size
        self.vehicle_name=vehicle_name
        self.maxspeed= maxspeed
        self.df=pd.DataFrame([[position.x_val, position.y_val, position.z_val,
                               velocity.x_val, velocity.y_val, velocity.z_val,
                              reward, time_stamp,vehicle_name]], columns=self.columns)

    def appendGPShistory(self, position, velocity, reward, time_stamp, vehicle_name):
        self.df.loc[len(self.df)]= [position.x_val, position.y_val, position.z_val,
                                    velocity.x_val, velocity.y_val, velocity.z_val,
                                    reward, time_stamp,vehicle_name]

    def saveGPS2csv(self, filename):
        self.df.to_csv(filename, index=False)

    def loadGPScsv(self, filename):
        self.df=pd.read_csv(filename)

    def getDataframe(self): return self.df

    def GPS2image(self, x_cntr, y_cntr, df_nofly=None):
        df=self.df.copy()
        maxspeed=self.maxspeed
        vehicle_name=self.vehicle_name
        sz=self.sz
        rad=100 # meters
        # ensures the current vehicle is plotted last
        vehicle_lst=list(df[df['vehicle_name']!=vehicle_name]['vehicle_name'].dropna().unique())+[vehicle_name]

        #################################### Plotting #########################################################
        fig, ax = plt.subplots(figsize=(5,5))
        ax=plt.gca(); ax.set_axis_off()
        ax.add_patch(patches.Rectangle((x_cntr-rad,y_cntr-rad+1), width=rad*2-1, height=rad*2-1, ec='k', facecolor='#b3b3b3'))
        ax.add_patch(plt.Circle((x_cntr,y_cntr), rad, ec='k', facecolor='white'))
        plt.xlim(x_cntr-rad,x_cntr+rad); plt.ylim(y_cntr-rad,y_cntr+rad)
        if df_nofly is not None: # plot the no fly zone
            for idx in df_nofly.index:
                ax.add_patch(plt.Circle((df_nofly.loc[idx,'x'], df_nofly.loc[idx,'y']), df_nofly.loc[idx,'radius'],
                                    hatch='xxx',facecolor='grey'))

        # Plot reward and history of drones
        for v_name in vehicle_lst:
            frame=df[df['vehicle_name']==v_name].copy()
            # set the most recent position to the center of plot and shows 100 meters in all directions
            lc = plotcolorline(frame['x_position'], frame['y_position'],frame['Reward'],
                               cmap='Greys_r', norm=plt.Normalize(-100, 20), linewidth=4,alpha=1.0)

        # ensure current locations are on top
        for v_name in vehicle_lst:
            frame=df[df['vehicle_name']==v_name].copy()
            if v_name==vehicle_name:
                #honey I'm home
                plt.plot(frame.loc[frame.index[0],'x_position'], frame.loc[frame.index[0],'y_position']
                         , marker='o', color="gray", ms=8, markeredgecolor='black',linestyle='None')
                # Current Location
                plt.plot(x_cntr, y_cntr ,marker='P', color='k', lw=6, ms=16, markeredgecolor='white',linestyle='None',markeredgewidth=2)

            else:
                #Last Location of other drones
                plt.plot(frame.loc[frame.index[-1],'x_position'], frame.loc[frame.index[-1],'y_position']
                         , marker='*', color="white", ms=14, markeredgecolor='k', linestyle='None', markeredgewidth=2)

        #ax.text(-85,85, f'{int(abs(z_cntr))}',  fontsize = 18)
        plt.tight_layout()
        fig.canvas.draw()

        # plot to image array
        arr = np.frombuffer(fig.canvas.tostring_rgb(), dtype=np.uint8)
        arr = arr.reshape(fig.canvas.get_width_height()[::-1] + (3,))
        arr = cv2.cvtColor(arr, cv2.COLOR_RGB2GRAY)
        # this padding only works for 224x224 images
        arr=cv2.resize(arr[9:-11, 9:-11], (sz), interpolation=cv2.INTER_CUBIC)
        # close the figure
        plt.close(fig)
        plt.figure().clear()
        plt.close()
        plt.cla()
        plt.clf()

        return arr


def Penalty4Backtrack(df_gps, x,y, dist=20, penalty=-3, drone_dict=None):
    ''' given gps dataframe x,y on most recent index
        calcuates the distance to previous x,y positions
        returns the reward for every position within dist
    '''
    df_tmp=df_gps.copy()
    if drone_dict is not None:
        idx2ignore=list(itertools.chain(*[list(df_tmp[df_tmp['vehicle_name']==vehicle_name].index[-4:])
                       for vehicle_name in drone_dict.keys()]))
    else: idx2ignore= list(df_tmp.index[-4:])

    df_tmp['Distance2Drone']=np.sqrt((x-df_tmp['x_position'])**2+ (y-df_tmp['y_position'])**2)
    return len(df_tmp[(df_tmp['Distance2Drone']<dist)&(~df_tmp.index.isin(idx2ignore))]) * penalty


def DroneDistanceReward(d):
    if d>=50:
        return  -math.exp(10-(-d+100)**0.5)/100
    else:
        return (-math.exp(-d**0.5+9))/100


def NoFlyZoneReward(d):
    if d<0: return -4000
    else: return max((-math.exp(-d**0.7+10))/60, -4000)

def HghtReward(z):
    if z>=31:
        return -math.exp(z**0.5)/300
    else:
        return -1/math.exp(z**0.5-10)/100


def plot_Reward(df_summary, path, filename, show=False):
    fig=plt.figure(figsize=(20, 12), dpi=80, facecolor='w', edgecolor='k')
    filename = os.path.join(path, f'{filename}.png')
    plt.scatter(df_summary['Episode'], df_summary['Score'], alpha=0.5, label='Episode Score')
    plt.plot(df_summary['Episode'], df_summary['Average Score'], color='orange', label='Running Average')
    plt.ylabel('Reward')
    plt.xlabel('Episodes')
    plt.legend(loc=2)

    #plt.ylim(-1000,10)
    plt.grid()


    plt.savefig(filename)
    if show: plt.show()

    plt.close(fig)
    plt.figure().clear()
    plt.close()
    plt.cla()
    plt.clf()



def RoadBelowReward(img, rng=50, reward=100):
    # input image
    # looks at center of image and gets the percent of pixels that are equal to 1. (road)
    # returns road percent * the reward
    x,y=img.shape
    x=int(x/2)
    y=int(y/2)
    try: return pd.DataFrame(img[x-rng:x+rng,y-rng:y+rng].flatten()).value_counts(normalize=True)[1]*reward
    except: return 0

def initialGPS(x_cntr,y_cntr, sz=(224, 224), df_nofly=None):
    #################################### Plotting #########################################################
    rad=100
    fig, ax = plt.subplots(figsize=(5,5))
    ax=plt.gca(); ax.set_axis_off()
    ax.add_patch(patches.Rectangle((x_cntr-rad,y_cntr-rad+1), width=rad*2-1, height=rad*2-1, ec='k', facecolor='#b3b3b3'))
    ax.add_patch(plt.Circle((x_cntr,y_cntr), rad, ec='k', facecolor='white'))
    plt.xlim(x_cntr-rad,x_cntr+rad); plt.ylim(y_cntr-rad,y_cntr+rad)

    if df_nofly is not None: # plot the no fly zone
        for idx in df_nofly.index:
            ax.add_patch(plt.Circle((df_nofly.loc[idx,'x'], df_nofly.loc[idx,'y']), df_nofly.loc[idx,'radius'],
                                hatch='xxx',facecolor='grey'))

    plt.plot(x_cntr, y_cntr ,marker='P', color='k', lw=6, ms=16, markeredgecolor='white',linestyle='None',markeredgewidth=2)
    plt.tight_layout()
    fig.canvas.draw()

    # plot to image array
    arr = np.frombuffer(fig.canvas.tostring_rgb(), dtype=np.uint8)
    arr = arr.reshape(fig.canvas.get_width_height()[::-1] + (3,))
    arr = cv2.cvtColor(arr, cv2.COLOR_RGB2GRAY)
    # this padding only works for 224x224 images
    arr=cv2.resize(arr[9:-11, 9:-11], (sz), interpolation=cv2.INTER_CUBIC)
    # close the figure
    plt.close(fig)
    plt.figure().clear()
    plt.close()
    plt.cla()
    plt.clf()

    return arr

def DistanceSensor2Image(x_cntr,y_cntr, distance_dict,scale=5, sz=(224, 224), df_nofly=None):
    front_dist = distance_dict['Front']
    back_dist = distance_dict['Back']
    left_dist = distance_dict['Left']
    right_dist = distance_dict['Right']
    z_ht = distance_dict['Z']
    rad=100
    
    #################################### Plotting #########################################################
    fig, ax = plt.subplots(figsize=(5,5))
    ax=plt.gca(); ax.set_axis_off()
    ax.add_patch(patches.Rectangle((x_cntr-rad,y_cntr-rad+1), width=rad*2-1, height=rad*2-1, ec='k', facecolor='#b3b3b3'))
    ax.add_patch(plt.Circle((x_cntr,y_cntr), rad, ec='k', facecolor='white'))
    plt.xlim(x_cntr-rad,x_cntr+rad); plt.ylim(y_cntr-rad,y_cntr+rad)

    if df_nofly is not None: # plot the no fly zone
        for idx in df_nofly.index:
            ax.add_patch(plt.Circle((df_nofly.loc[idx,'x'], df_nofly.loc[idx,'y']), df_nofly.loc[idx,'radius'],
                                hatch='xxx',facecolor='grey'))

    # Front (in image to the right)
    plt.plot([x_cntr,x_cntr+front_dist], [y_cntr,y_cntr] ,lw=6, color=Value2Color(z_ht, vmin=-10, vmax=120, palette='Greys', zerocolor='#e3e3e3'))
    if front_dist<scale*1.1: plt.plot(x_cntr+front_dist, y_cntr ,marker='x', color='k', lw=6, ms=16,linestyle='None')
    # Back (in image to the left)
    plt.plot([x_cntr,x_cntr-back_dist], [y_cntr,y_cntr] ,lw=6, color=Value2Color(z_ht, vmin=-10, vmax=120, palette='Greys', zerocolor='#e3e3e3'))
    if back_dist<scale*1.1: plt.plot(x_cntr-back_dist, y_cntr ,marker='x', color='k', lw=6, ms=16,linestyle='None')
    # Left (in image to the top)
    plt.plot([x_cntr,x_cntr], [y_cntr,y_cntr+left_dist] ,lw=6, color=Value2Color(z_ht, vmin=-10, vmax=120, palette='Greys', zerocolor='#e3e3e3'))
    if left_dist<scale*1.1: plt.plot(x_cntr, y_cntr+left_dist ,marker='x', color='k', lw=6, ms=16,linestyle='None')
    # Reft (in image to the bottom)
    plt.plot([x_cntr,x_cntr], [y_cntr,y_cntr-right_dist] ,lw=6, color=Value2Color(z_ht, vmin=-10, vmax=120, palette='Greys', zerocolor='#e3e3e3'))
    if right_dist<scale*1.1: plt.plot(x_cntr, y_cntr-right_dist ,marker='x', color='k', lw=6, ms=16,linestyle='None')

        # current Location
    plt.plot(x_cntr, y_cntr ,marker='P', color='k', lw=6, ms=16, markeredgecolor='white',linestyle='None',markeredgewidth=2)

    plt.tight_layout()
    fig.canvas.draw()

    # plot to image array
    arr = np.frombuffer(fig.canvas.tostring_rgb(), dtype=np.uint8)
    arr = arr.reshape(fig.canvas.get_width_height()[::-1] + (3,))
    arr = cv2.cvtColor(arr, cv2.COLOR_RGB2GRAY)
    # this padding only works for 224x224 images
    arr=cv2.resize(arr[9:-11, 9:-11], (sz), interpolation=cv2.INTER_CUBIC)

    # close the figure
    plt.close(fig)
    plt.figure().clear()
    plt.close()
    plt.cla()
    plt.clf()

    return arr
